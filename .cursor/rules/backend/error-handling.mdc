---
description: Enforces error handling standards including exception filters, NestJS exceptions, and consistent error responses for TravelSplit backend.
globs:
  - Backend/src/**/*.ts
alwaysApply: false
---

# Error Handling Standards

## Rules

- Use NestJS built-in exceptions for HTTP errors.
- Create global exception filter for consistent error responses.
- Log errors before handling or rethrowing.
- Provide user-friendly error messages in Spanish.
- Never expose internal implementation details in error messages.
- Use appropriate HTTP status codes.
- Handle errors at appropriate layer (service throws, controller catches, filter formats).
- Async/await: services must throw (not swallow with .catch) so errors bubble; controllers must await/return service Promises so Nest/global filters catch them; nested async calls should await or propagate; rely on global unhandled rejection handling (e.g., AppExceptionFilter or process-level handler) to avoid silent promise rejections.

## Exception Types

- Use `BadRequestException` (400) for validation errors.
- Use `UnauthorizedException` (401) for authentication failures.
- Use `ForbiddenException` (403) for authorization failures.
- Use `NotFoundException` (404) for resource not found.
- Use `ConflictException` (409) for duplicate resources.
- Use `InternalServerErrorException` (500) for unexpected errors.
- Create custom exceptions extending `HttpException` when needed.

## Global Exception Filter

- Create exception filter in `common/filters/` directory.
- Implement `ExceptionFilter` interface.
- Catch all exceptions and format consistently.
- Log errors with context (method, URL, stack trace).
- Return consistent error response format.
- Register filter globally in `main.ts`.

## Error Response Format

- Include `statusCode`, `timestamp`, `path`, `method`, `message`.
- Use consistent structure across all error responses.
- Do not expose stack traces in production.
- Provide actionable error messages.

## Service Layer Error Handling

- Services throw NestJS exceptions.
- Services log errors before throwing.
- Services provide context in error messages.
- Services do not catch exceptions unless transforming them.

## Controller Layer Error Handling

- Controllers delegate error handling to services.
- Controllers let exceptions bubble up to global filter.
- Controllers do not catch exceptions unless adding context.
- Controllers use appropriate HTTP status decorators.

## Logging Errors

- Log errors with Logger from `@nestjs/common`.
- Include request context: method, URL, user ID if available.
- Log stack traces for debugging.
- Use appropriate log levels: `error`, `warn`, `debug`.

## DO

```typescript
// Global exception filter
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);
  
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    
    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;
    
    const rawResponse =
      exception instanceof HttpException
        ? exception.getResponse()
        : 'Error interno del servidor';

    let safeMessage: string;
    if (typeof rawResponse === 'string') {
      safeMessage = rawResponse;
    } else if (Array.isArray(rawResponse)) {
      safeMessage = rawResponse.map((item) => String(item)).join(', ');
    } else if (rawResponse && typeof rawResponse === 'object') {
      const maybeMessage = (rawResponse as { message?: unknown }).message;
      if (typeof maybeMessage === 'string') {
        safeMessage = maybeMessage;
      } else if (Array.isArray(maybeMessage)) {
        safeMessage = maybeMessage.map((item) => String(item)).join(', ');
      } else {
        safeMessage = JSON.stringify(rawResponse);
      }
    } else {
      safeMessage = 'Ocurri칩 un error';
    }

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message: safeMessage,
    };

    // Respect logger level; avoid dumping full stacks in prod unless configured
    if (exception instanceof Error) {
      this.logger.error(`${request.method} ${request.url}`, exception.stack);
    } else {
      this.logger.error(`${request.method} ${request.url}`, JSON.stringify(exception));
    }
    
    response.status(status).json(errorResponse);
  }
}

// Service throwing exceptions
@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name);
  
  async findOne(id: string): Promise<User> {
    const user = await this.userRepository.findOne({
      where: { id, deletedAt: IsNull() },
    });
    
    if (!user) {
      this.logger.warn(`User with ID ${id} not found`);
      throw new NotFoundException(`Usuario con ID ${id} no encontrado`);
    }
    
    return user;
  }

  // Resilience guidance for transient DB failures (findOne/read paths)
  // - Default: no retries for repository reads unless you apply bounded exponential backoff.
  // - If needed, keep resilience inside the service (closest to the repository call) or a dedicated infra helper; do not sprinkle ad-hoc retries across controllers.
  // - Use small, capped retries for idempotent reads only (e.g., 2-3 attempts, exponential backoff, jitter) to avoid hammering the DB.
  // - Circuit breakers belong in infra/middleware (e.g., wrapping the data source/ORM) to prevent cascading failures.
  // Example with p-retry (pseudo):
  // const user = await retry(() => this.userRepository.findOne({ where: { id, deletedAt: IsNull() } }), {
  //   retries: 2,
  //   factor: 2,
  //   minTimeout: 100,
  //   maxTimeout: 500,
  //   onFailedAttempt: (err) => this.logger.warn(`Retry findOne user ${id}: attempt ${err.attemptNumber}`),
  // });
  // Example circuit-breaker placement (pseudo): wrap the underlying data source/repo factory; the service should call the wrapped repo rather than implement breaker logic itself.
  
  async create(createUserDto: CreateUserDto): Promise<User> {
    const existingUser = await this.userRepository.findOne({
      where: { email: createUserDto.email, deletedAt: IsNull() },
    });
    
    if (existingUser) {
      this.logger.warn(`Attempt to create user with existing email: ${createUserDto.email}`);
      throw new ConflictException('El email ya est치 registrado');
    }
    
    try {
      const passwordHash = await bcrypt.hash(createUserDto.contrase침a, 10);
      const user = this.userRepository.create({
        ...createUserDto,
        passwordHash,
      });
      return await this.userRepository.save(user);
    } catch (error) {
      this.logger.error('Failed to create user', error);
      throw new InternalServerErrorException('No se pudo crear el usuario');
    }
  }
}

// Controller using appropriate status codes
@Controller('users')
export class UsersController {
  @Get(':id')
  @ApiNotFoundResponse({ description: 'Usuario no encontrado' })
  async findOne(@Param('id', ParseUUIDPipe) id: string): Promise<UserResponseDto> {
    return this.usersService.findOne(id);
  }
  
  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ApiConflictResponse({ description: 'El email ya est치 registrado' })
  async create(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {
    return this.usersService.create(createUserDto);
  }
}

// Controller Layer Error Handling guidance
// - Annotate all mutation endpoints (POST/PUT/PATCH/DELETE) with explicit @HttpCode(...) values; do not rely on Nest defaults.
// - Example above: UsersController.create uses @HttpCode(HttpStatus.CREATED); update other mutations likewise (e.g., PATCH -> 200/204, DELETE -> 204).
// - Keep success and error codes explicit to improve maintainability and API contract clarity.
```

```typescript
// Register global filter in main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new AllExceptionsFilter());
  await app.listen(3000);
}
```

## DON'T

```typescript
// VIOLATION: Generic error without context
async findOne(id: string): Promise<User> {
  const user = await this.userRepository.findOne({ where: { id } });
  if (!user) {
    throw new Error('Not found'); // VIOLATION: Use NotFoundException with message
  }
  return user;
}
```

```typescript
// VIOLATION: Exposing internal details
async create(dto: CreateUserDto): Promise<User> {
  try {
    return await this.userRepository.save(dto);
  } catch (error) {
    throw new Error(`Database error: ${error.message}`); // VIOLATION: Exposes DB details
  }
}
```

```typescript
// VIOLATION: Swallowing errors
async deleteUser(id: string): Promise<void> {
  try {
    await this.userRepository.softRemove({ id });
  } catch (error) {
    // VIOLATION: Error swallowed, no handling
  }
}
```

```typescript
// VIOLATION: Wrong HTTP status code
@Get(':id')
async findOne(@Param('id') id: string) {
  const user = await this.usersService.findOne(id);
  if (!user) {
    throw new BadRequestException('User not found'); // VIOLATION: Should be NotFoundException
  }
  return user;
}
```

```typescript
// VIOLATION: Not logging errors
async create(dto: CreateUserDto): Promise<User> {
  const existing = await this.userRepository.findOne({
    where: { email: dto.email },
  });
  if (existing) {
    throw new ConflictException('Email exists'); // VIOLATION: No logging
  }
}
```

```typescript
// VIOLATION: Catching and rethrowing without context
async findOne(id: string): Promise<User> {
  try {
    return await this.userRepository.findOne({ where: { id } });
  } catch (error) {
    throw error; // VIOLATION: No context added
  }
}
```

## Custom Exceptions

- Extend `HttpException` for custom exceptions.
- Place custom exceptions in `common/exceptions/` directory.
- Provide meaningful error messages.
- Use appropriate HTTP status codes.

## Error Message Guidelines

- Write error messages in Spanish.
- Make messages user-friendly and actionable.
- Do not expose technical details (database errors, stack traces).
- Provide context about what went wrong.
- Suggest how to fix the error when possible.

## Exception Filter Registration

- Register global filter in `main.ts` using `app.useGlobalFilters()`.
- Register specific filters at controller level using `@UseFilters()`.
- Use global filter for consistent error handling.
- Use specific filters for custom error formatting when needed.

## Exceptions

- Health check endpoints may return simple errors without full error response format.
- Test files may use generic Error for simplicity.
- Development mode may include stack traces in error responses.
