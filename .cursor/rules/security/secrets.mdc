---
description: Enforces secure handling of secrets, environment variables, and sensitive configuration for TravelSplit backend.
globs:
  - Backend/src/config/**/*.ts
  - Backend/.env*
  - Backend/src/**/*.ts
alwaysApply: false
---

# Secrets Management Standards

## Rules

- Store all secrets in environment variables, never in code.
- Use `@nestjs/config` ConfigService to access environment variables.
- Validate required secrets at application startup.
- Use different secrets for different environments (development, staging, production).
- Never commit secrets to version control.
- Use `.env.example` file to document required environment variables.
- Throw errors if required secrets are missing.
- Use strong, random secrets (minimum 32 characters for JWT).

## Environment Variables

- Store secrets in `.env` file (not committed to git).
- Document required variables in `.env.example`.
- Use descriptive variable names: `JWT_SECRET`, `DB_PASSWORD`, `DB_HOST`.
- Use `UPPER_SNAKE_CASE` for environment variable names.
- Provide sensible defaults for development only.

## ConfigService Usage

- Use `ConfigService` from `@nestjs/config` to access environment variables.
- Create configuration files in `config/` directory using `registerAs()`.
- Validate required secrets in configuration files.
- Throw errors immediately if required secrets are missing.
- Use type-safe configuration with TypeScript interfaces.

## Secret Validation

- Validate JWT secret is set and not empty.
- Validate database credentials are provided.
- Validate all required secrets before application starts.
- Provide clear error messages when secrets are missing.
- Fail fast: throw errors during module initialization.

## Configuration Files

- Create separate config files: `jwt.config.ts`, `database.config.ts`, `app.config.ts`.
- Use `registerAs()` for namespace configuration.
- Validate secrets in config file factory functions.
- Export configuration as default export.
- Use `ConfigModule.forFeature()` to load feature-specific configs.

## DO

```typescript
// JWT configuration with validation
import { registerAs } from '@nestjs/config';

export default registerAs('jwt', () => {
  const secret = process.env.JWT_SECRET;
  
  if (!secret || secret.trim() === '') {
    throw new Error(
      'JWT_SECRET no está configurado. Por favor, configure la variable de entorno JWT_SECRET antes de iniciar la aplicación.',
    );
  }
  
  return {
    secret,
    expiresIn: process.env.JWT_EXPIRES_IN || '3600',
  };
});

// Database configuration with validation
export const getDatabaseConfig = (configService: ConfigService): TypeOrmModuleOptions => {
  const host = configService.get<string>('DB_HOST');
  const database = configService.get<string>('DB_NAME');
  const username = configService.get<string>('DB_USERNAME');
  const password = configService.get<string>('DB_PASSWORD');
  
  if (!host || !database || !username || !password) {
    throw new Error(
      'Database configuration incomplete. Please set DB_HOST, DB_NAME, DB_USERNAME, and DB_PASSWORD environment variables.',
    );
  }
  
  return {
    type: 'postgres',
    host,
    port: configService.get<number>('DB_PORT', 5432),
    username,
    password,
    database,
    entities: [__dirname + '/../**/*.entity{.ts,.js}'],
    synchronize: configService.get<boolean>('DB_SYNCHRONIZE', false),
    logging: configService.get<boolean>('DB_LOGGING', false),
  };
};

// App configuration
export default registerAs('app', () => ({
  port: parseInt(process.env.PORT || '3000', 10),
  environment: process.env.NODE_ENV || 'development',
  apiPrefix: process.env.API_PREFIX || 'api',
  corsOrigins: process.env.CORS_ORIGINS
    ? process.env.CORS_ORIGINS.split(',').map(origin => origin.trim())
    : ['http://localhost:5173'],
}));

// Using ConfigService in modules
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [appConfig, jwtConfig],
      envFilePath: ['.env.local', '.env'],
    }),
    JwtModule.registerAsync({
      imports: [ConfigModule.forFeature(jwtConfig)],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => {
        const jwtSecret = configService.get<string>('jwt.secret');
        
        if (!jwtSecret || jwtSecret.trim() === '') {
          throw new Error('JWT_SECRET is required');
        }
        
        return {
          secret: jwtSecret,
          signOptions: {
            expiresIn: configService.get<string>('jwt.expiresIn', '3600s'),
          },
        };
      },
    }),
  ],
})
export class AuthModule {}
```

```typescript
// .env.example file (documentation)
# JWT Configuration
JWT_SECRET=your-secret-key-here-minimum-32-characters
JWT_EXPIRES_IN=3600

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=your-database-password
DB_NAME=travelsplit
DB_SYNCHRONIZE=false
DB_LOGGING=false

# Application Configuration
PORT=3000
NODE_ENV=development
API_PREFIX=api
CORS_ORIGINS=http://localhost:5173
```

## DON'T

```typescript
// VIOLATION: Hardcoded secrets
const jwtSecret = 'my-secret-key'; // VIOLATION: Should use environment variable
const dbPassword = 'password123'; // VIOLATION: Should use environment variable
```

```typescript
// VIOLATION: Not validating secrets
export default registerAs('jwt', () => ({
  secret: process.env.JWT_SECRET, // VIOLATION: No validation, could be undefined
}));
```

```typescript
// VIOLATION: Committing secrets to git
// .env file committed to repository // VIOLATION: Should be in .gitignore
```

```typescript
// VIOLATION: Using same secret for all environments
const jwtSecret = 'development-secret'; // VIOLATION: Should be different per environment
```

```typescript
// VIOLATION: Not using ConfigService
const jwtSecret = process.env.JWT_SECRET; // VIOLATION: Should use ConfigService
```

```typescript
// VIOLATION: Weak secret
JWT_SECRET=12345 // VIOLATION: Too short, should be minimum 32 characters
```

```typescript
// VIOLATION: Not failing fast on missing secrets
const jwtSecret = process.env.JWT_SECRET || 'default-secret'; // VIOLATION: Should throw error
```

## Secret Strength Requirements

- JWT secrets: Minimum 32 characters, random and unpredictable.
- Database passwords: Strong passwords following security policies.
- API keys: Use strong, randomly generated keys.
- Session secrets: Minimum 32 characters, random.

## Environment-Specific Secrets

- Development: Use `.env.local` for local development secrets.
- Staging: Use environment variables in deployment platform.
- Production: Use secure secret management (AWS Secrets Manager, Azure Key Vault, etc.).
- Never share secrets between environments.

## Secret Rotation

- Plan for secret rotation in production.
- Use environment variables for easy rotation.
- Document rotation procedures.
- Test secret rotation in staging first.

## .gitignore Requirements

- Add `.env` to `.gitignore`.
- Add `.env.local` to `.gitignore`.
- Add `.env.*.local` to `.gitignore`.
- Commit `.env.example` as documentation.
- Never commit actual `.env` files.

## Configuration Best Practices

- Use `registerAs()` for namespace organization.
- Validate secrets in config factory functions.
- Provide clear error messages for missing secrets.
- Use type-safe configuration with TypeScript.
- Document all required environment variables.

## Exceptions

- Test files may use hardcoded test secrets.
- Development mode may use default values (not recommended for production secrets).
- Configuration examples may show placeholder values.
